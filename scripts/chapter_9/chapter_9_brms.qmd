---
title: "9 Markov Chain Monte Carlo"
format: html
---

## 9.1 Good King Markov and his island kingdom
```{r}
set.seed(9)

num_weeks <- 1e5
positions <- rep(0, num_weeks)
current <- 10

for (i in 1:num_weeks){
  # record current position
  positions[i] <- current
  
  # flip coin to generate proposal
  proposal <- current + sample(c(-1, 1), size = 1)
  
  # now make sure he loops around the archipelago
  if (proposal < 1) proposal <- 10
  if (proposal > 10) proposal <- 1
  
  # move?
  prob_move <- proposal / current
  current <- ifelse(runif(1) < prob_move, proposal, current)
}
```

```{r}
library(ggpomological)
```

```{r}
scales::show_col(ggpomological:::pomological_palette)
```

```{r}
pomological_palette <- ggpomological:::pomological_palette
```

```{r}
library(tidyverse)

tibble(week = 1:1e5,
       island = positions) %>% 
  ggplot(aes(x = week, y = island)) +
  geom_point(shape = 1, color = pomological_palette[1]) +
  scale_x_continuous(breaks = seq(from = 0, to = 100, by = 20)) +
  scale_y_continuous(breaks = seq(from = 0, to = 10, by = 2)) +
coord_cartesian(xlim = c(0, 100)) +
  labs(title = "Behold the Metropolis algorithm in action!",
       subtitle = "The dots show the king's path over the first 100 weeks.") +
  theme_pomological_fancy(base_family = "Marck Script")
```

```{r}
tibble(week = 1:1e5,
       island = positions) %>% 
  mutate(island = factor(island)) %>% 
  
  ggplot(aes(x = island)) +
  geom_bar(fill = pomological_palette[2]) +
  scale_y_continuous("number of weeks", expand = expansion(mult = c(0, .05))) +
  labs(title = "Old Metropolis shines in the long run.",
       subtitle = "Sure enough, the time the king spent on each island\nwas proportional to its population size.") +
  theme_pomological_fancy(base_family = "Marck Script")
```

## 9.2 Metropolis algorithms
### 9.2.2 High-dimensional problems
```{r}
# mean vector
mu <- c(0, 0)

# variance/covariance matrix
sd_a1 <- 0.22
sd_a2 <- 0.22
rho <- -0.9

Sigma <- matrix(data = c(sd_a1^2,
                         rho * sd_a1 * sd_a2,
                         rho * sd_a1 * sd_a2,
                         sd_a2^2),
                nrow = 2)

# sample from the distribution with the 'mvtnorm::rmvnorm()' function
set.seed(9)

my_samples <- mvtnorm::rmvnorm(n = 1000, mean = mu, sigma = Sigma)
```

Check the sample correlation
```{r}
data.frame(my_samples) %>% 
  set_names(str_c("a", 1:2)) %>% 
  summarise(rho = cor(a1, a2))
```

```{r}
# define the function
x_y_grid <- function(x_start = -1.6,
                     x_stop = 1.6,
                     x_length = 100,
                     y_start = -1.6,
                     y_stop = 1.6,
                     y_length = 100){
  x_domain <- seq(from = x_start, to = x_stop, length.out = x_length)
  y_domain <- seq(from = y_start, to = y_stop, length.out = y_length)
  
  x_y_grid_tibble <- tidyr::expand_grid(a1 = x_domain, a2 = y_domain)
  
  return(x_y_grid_tibble)
}

# simulate
contour_plot_dat <- x_y_grid()

# what have we dont?
str(contour_plot_dat)
```

Compute density values for each combination of a1 and a2
```{r}
contour_plot_dat <-
  contour_plot_dat %>% 
  mutate(d = mvtnorm::dmvnorm(as.matrix(contour_plot_dat), mean = mu, sigma = Sigma))

head(contour_plot_dat)
```

Data in 2D density plot
```{r}
contour_plot_dat %>% 
  ggplot(aes(x = a1, y = a2, fill = d)) +
  geom_raster(interpolate = T) +
  scale_fill_gradientn(colors = pomological_palette[c(8, 2, 4)],
                       limits = c(0, NA)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_pomological_fancy(base_family = "Marck Script")
```

We make contour lines
```{r}
contour_plot <-
  contour_plot_dat %>% 
  ggplot() +
  geom_contour(aes(x = a1, y = a2, z = d),
               linewidth = 1/8, color = pomological_palette[4],
               breaks = 9^(-(10 * 1:25))) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_pomological_fancy(base_family = "Marck Script")

contour_plot
```

Metropolis()
```{r}
metropolis <- function(num_proposals = 50,
                       step_size = 0.1,
                       starting_point = c(-1, 1)){
  
  # Initialize vectors where we will keep track of relevant
  candidate_x_history <- rep(-Inf, num_proposals)
  candidate_y_history <- rep(-Inf, num_proposals)
  did_move_history <- rep(FALSE, num_proposals)
  
  # Prepare to begin the algorithm
  current_point <- starting_point
  
  for(i in 1:num_proposals){
    
    # "Proposals are generated by adding random Gaussian noise
    # to each parameter"
    
    noise <- rnorm(n = 2, mean = 0, sd = step_size)
    candidate_point <- current_point + noise
    
    # store coordinates of the proposal point
    candidate_x_history[i] <- candidate_point[1]
    candidate_y_history[i] <- candidate_point[2]
    
    # evaluate the density of our posterior at the proposal point
    candidate_prob <- mvtnorm::dmvnorm(candidate_point, mean = mu, sigma = Sigma)
    
    # evaluate the density of our posterior at the current point
    current_prob <- mvtnorm::dmvnorm(current_point, mean = mu, sigma = Sigma)
    
    # Decide whether or not we should move to the candidate point
    acceptance_ratio <- candidate_prob / current_prob
    should_move <- ifelse(runif(n = 1) < acceptance_ratio, TRUE, FALSE)
    
    # Keep track of the decision
    did_move_history[i] <- should_move
    
    # Move if necessary
    if(should_move){
      current_point <- candidate_point
    }
  }
  
  # once the loop is complete, store the relevant results in a tibble
  results <- tibble::tibble(
    candidate_x = candidate_x_history,
    candidate_y = candidate_y_history,
    accept = did_move_history
  )
  
  # compute the "acceptance rate" by dividing the total number of "moves"
  # by the total number of proposals
  
  number_of_moves <- results %>% dplyr::pull(accept) %>% sum(.)
  acceptance_rate <- number_of_moves / num_proposals
  
  return(list(results = results, acceptance_rate = acceptance_rate))
}
```

Run the algorithm
```{r}
set.seed(9)

round_1 <- metropolis(num_proposals = 50,
                      step_size = 0.1,
                      starting_point = c(-1, 1))
```

```{r}
p1 <-
  contour_plot + 
  geom_point(data = round_1$results,
             aes(x = candidate_x, y = candidate_y, 
                 color = accept, shape = accept)) +
  labs(subtitle = str_c("step size 0.1,\naccept rate ", round_1$acceptance_rate),
       x = "a1",
       y = "a2") +
  scale_shape_manual(values = c(21, 19)) +
  scale_color_manual(values = pomological_palette[8:9]) +
  theme_pomological_fancy(base_family = "Marck Script")

p1
```

Run the algorithm with step size 0.25
```{r}
# simulate
set.seed(9)

round_2 <- metropolis(num_proposals = 50,
                      step_size = 0.25,
                      starting_point = c(-1,1))

# plot
p2 <-
  contour_plot + 
  geom_point(data = round_2$results,
             aes(x = candidate_x, y = candidate_y, 
                 color = accept, shape = accept)) +
  scale_shape_manual(values = c(21, 19)) +
  scale_color_manual(values = pomological_palette[8:9]) +
  scale_y_continuous(NULL, breaks = NULL, expand = c(0, 0)) +
  labs(subtitle = str_c("step size 0.25,\naccept rate ", round_2$acceptance_rate),
       x = "a1") +
  theme_pomological_fancy(base_family = "Marck Script")

# combine
library(patchwork)
(p1 + p2) + 
  plot_annotation(theme = theme_pomological_fancy(base_family = "Marck Script"),
                  title = "Metropolis chains under high correlation") +
  plot_layout(guides = "collect")
```

Wrap metropolis inside another function that takes a simulation seed value
```{r}
metropolis_with_seed <- function(seed, step_size = 0.1) {
  
  set.seed(seed)
  
  met <-
    metropolis(num_proposals = 50,
               step_size = step_size,
               starting_point = c(-1, 1))
  
  return(met$acceptance_rate)
  
}
```

Iterates 500 times
```{r}
ars <-
  tibble(seed = 1:500) %>% 
  mutate(acceptance_rate = map_dbl(seed, metropolis_with_seed)) 
```

Summarize the results in a histogram
```{r}
ars %>% 
  ggplot(aes(x = acceptance_rate)) +
  geom_histogram(binwidth = .025, fill = pomological_palette[5]) +
  theme_pomological_fancy(base_family = "Marck Script")
```

```{r}
concentration_sim <- function(d = 1, t = 1e3, seed = 9){
  set.seed(seed)
  
  y <- rethinking::rmvnorm(t, rep(0, d), diag(d))
  rad_dist <- function(y) sqrt(sum(y^2))
  rd <- sapply(1:t, function(i) rad_dist(y[i, ]))
}
```

```{r}
d <-
  tibble(d = c(1, 10, 100, 1000)) %>% 
  mutate(con = map(d, concentration_sim)) %>% 
  unnest(con) %>% 
  mutate(`# dimensions` = factor(d)) 

d  %>% 
  ggplot(aes(x = con, fill = `# dimensions`)) +
  geom_density(linewidth = 0, alpha = 3/4) +
  scale_fill_pomological() +
  xlab("Radial distance from mode") +
  theme_pomological_fancy(base_family = "Marck Script") +
  theme(legend.position = c(.7, .625))
```

## 9.3 Hamiltonian Monte Carlo

## 9.4 Easy HMR: brm()
```{r}
library(brms)
data(rugged, package = "rethinking")
d <- rugged
rm(rugged)
```

```{r}
d <-
  d %>% 
  mutate(log_gdp = log(rgdppc_2000))

dd <-
  d %>% 
  drop_na(rgdppc_2000) %>% 
  mutate(log_gdp_std = log_gdp / mean(log_gdp),
         rugged_std = rugged / max(rugged),
         cid = ifelse(cont_africa == 1, "1", "2")) %>% 
  mutate(rugged_std_c = rugged_std - mean(rugged_std))
```

### 9.4.1 Preparation
```{r}
dat_slim <-
  dd %>% 
  mutate(cid = as.integer(cid)) %>% 
  select(log_gdp_std, rugged_std, cid, rugged_std_c) %>% 
  list()

str(dat_slim)
```

### 9.4.2 Sampling from the posterior
```{r}
b9.1 <-
  brm(data = dd,
      family = gaussian,
      bf(log_gdp_std ~ 0 + a + b * (rugged_std - 0.215),
         a ~ 0 + cid,
         b ~ 0 + cid,
         nl = TRUE),
      prior = c(prior(normal(1, .1), class = b, coef = cid1, nlpar = a),
                prior(normal(1, .1), class = b, coef = cid2, nlpar = a),
                prior(normal(0, .3), class = b, coef = cid1, nlpar = b),
                prior(normal(0, .3), class = b, coef = cid2, nlpar = b),
                prior(exponential(1), class = sigma)),
      chains = 1, cores = 1,
      seed = 9,
      file = "fits/b09.01")
```

```{r}
print(b9.1)
```

```{r}
library(tidybayes)

post <- as_draws_df(b9.1)

post %>% 
  pivot_longer(b_a_cid1:sigma) %>% 
  group_by(name) %>% 
  mean_hdi(value, .width = .89) # note our rare use of 89% intervals
```

### 9.4.3 Sampling again, in parallel
```{r}
parallel::detectCores()
```

```{r}
b9.1b <-
  update(b9.1,
         chains = 4, cores = 4,
         seed = 9,
         file = "fits/b09.01b")
```

```{r}
print(b9.1b)
```

```{r}
show(b9.1b)
```

```{r}
b9.1b$formula
```

```{r}
b9.1b$prior
```

```{r}
prior_summary(b9.1b)
```

### 9.4.4 Visualization
```{r}
pairs(b9.1b,
      off_diag_args = list(size = 1/5, alpha = 1/5))
```

```{r}
vcov(b9.1b, correlation = T) %>% round(digits = 2)
```

Use ```brms::as_draws_df()``` function to extract the posterior samples within a data frame.
```{r}
post <- as_draws_df(b9.1b)

glimpse(post)
```
Customize pairs plot with GGally package
```{r}
library(GGally)

post %>% 
  select(b_a_cid1:sigma) %>% 
  ggpairs()
```

Sincee ```GGally::ggpairs()``` returns a ggplot2 object, you can customize it as you please
```{r}
# make the custom functions
my_diag <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping) + 
    geom_density(fill = pomological_palette[7],
                 color = pomological_palette[6])
}

my_upper <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping) + 
    geom_bin2d() +
    scale_fill_gradient(low = pomological_palette[4], 
                        high = pomological_palette[1])
}

# plot!
post %>%
  select(b_a_cid1:sigma) %>%
  ggpairs(lower = list(continuous = wrap("cor", family = "Marck Script", color = "black")),
          diag = list(continuous = my_diag),
          upper = list(continuous = my_upper)) +
  labs(subtitle = "My custom pairs plot") +
  theme_pomological_fancy(base_family = "Marck Script")
```

### 9.4.5 Checking the chain
```{r}
plot(b9.1b, widths = c(1, 2))
```

```{r}
library(bayesplot)

as_draws_df(b9.1b) %>% 
  mcmc_trace(pars = vars(b_a_cid1:sigma),
             facet_args = list(ncol = 3),
             linewidth = .15) +
  scale_color_pomological() +
  labs(title = "My custom trace plots") +
  theme_pomological_fancy(base_family = "Marck Script") +
  theme(legend.position = c(.95, .2))
```

Autocorrelation plots for all models parameters, one for each HMC chain
```{r}
as_draws_df(b9.1b) %>% 
  mcmc_acf(pars = vars(b_a_cid1:sigma), lags = 5) +
  theme_pomological_fancy(base_family = "Marck Script")
```

```{r}
library(ggmcmc)
```

```{r}
ggs(b9.1b) %>% str()
```

```{r}
ggs(b9.1b) %>% 
  mutate(chain = factor(Chain)) %>% 
  
  ggplot(aes(x = Iteration, y = value)) +
  # this marks off the warmups
  annotate(geom = "rect",
           xmin = 0, xmax = 1000, ymin = -Inf, ymax = Inf,
           fill = pomological_palette[9], alpha = 1/6, linewidth = 0) +
  geom_line(aes(color = chain),
            linewidth = .15) +
  scale_color_pomological() +
  labs(title = "My custom trace plots with warmups via ggmcmc::ggs()",
       x = NULL, y = NULL) +
  theme_pomological_fancy(base_family = "Marck Script") +
  theme(legend.position =  c(.95, .18)) +
  facet_wrap(~ Parameter, scales = "free_y")
```

```{r}
ggs(b9.1b) %>%
  mutate(chain = factor(Chain)) %>% 
  
  ggplot(aes(x = Iteration, y = value, color = chain)) +
  annotate(geom = "rect", 
           xmin = 0, xmax = 1000, ymin = -Inf, ymax = Inf,
           fill = pomological_palette[9], alpha = 1/6, linewidth = 0) +
  geom_line(linewidth = 0.5) +
  scale_color_pomological() +
  labs(title = "Another custom trace plots with warmups via ggmcmc::ggs()",
       x = NULL, y = NULL) +
  coord_cartesian(xlim = c(1, 50)) +
  theme_pomological_fancy(base_family = "Marck Script") +
  theme(legend.position = c(.95, .18)) +
  facet_wrap(~ Parameter, scales = "free_y")
```

```{r}
as_draws_df(b9.1b) %>%  
  mcmc_rank_overlay(pars = vars(b_a_cid1:sigma)) +
  scale_color_pomological() +
  labs(title = "My custom trank plots",
       x = NULL) +
  coord_cartesian(ylim = c(25, NA)) +
  theme_pomological_fancy(base_family = "Marck Script") +
  theme(legend.position = c(.95, .2))
```

#### 9.4.5.1 Overthinking: Raw Stan model code.
```{r}
brms::stancode(b9.1b)
```

## 9.5 Care and feeding of your Markov Chain
### 9.5.3 Taming a wild chain
```{r}
b9.2 <-
  brm(data = list(y = c(-1, 1)), 
      family = gaussian,
      y ~ 1,
      prior = c(prior(normal(0, 1000), class = Intercept),
                prior(exponential(0.0001), class = sigma)),
      iter = 2000, warmup = 1000, chains = 3,
      seed = 9,
      file = "fits/b09.02")
```

```{r}
print(b9.2)
```

The brms::nuts_params() function allows use to pull a wealth of diagnostic information for the chains from a brms fit. The different kinds of diagnostics are listed in the Parameter column.
```{r}
nuts_params(b9.2) %>% distinct(Parameter)
```

```{r}
nuts_params(b9.2) %>% 
  filter(Parameter == "divergent__") %>% 
  count(Value)
```

```{r}
pairs(b9.2, 
      # currently not working with bayesplot 1.10.0
      # see https://github.com/stan-dev/bayesplot/issues/298
      # np = nuts_params(b9.2),
      off_diag_args = list(size = 1/4))
```

Inspect the damage by making the top two rows of Figure 9.9
```{r}
p1 <-
  as_draws_df(b9.2) %>% 
  mcmc_trace(pars = vars(b_Intercept:sigma),
             linewidth = 0.25)

p2 <-
  as_draws_df(b9.2) %>% 
  mcmc_rank_overlay(pars = vars(b_Intercept:sigma))

(
  (p1 / p2) &
    scale_color_pomological() &
    theme_pomological_fancy(base_family = "Marck Script") &
    theme(legend.position = "none")
) +
  plot_annotation(subtitle = "These chains are not healthy")
```

Watch our new priors save the day
```{r}
b9.3 <-
  brm(data = list(y = c(-1, 1)), 
      family = gaussian,
      y ~ 1,
      prior = c(prior(normal(1, 10), class = Intercept),
                prior(exponential(1), class = sigma)),
      iter = 2000, warmup = 1000, chains = 3,
      seed = 9,
      file = "fits/b09.03")
```

```{r}
print(b9.3)
```

The trace and trank plot look better
```{r}
p1 <-
  as_draws_df(b9.3) %>% 
  mcmc_trace(pars = vars(b_Intercept:sigma),
             linewidth = 0.25)

p2 <-
  as_draws_df(b9.3) %>% 
  mcmc_rank_overlay(pars = vars(b_Intercept:sigma)) +
  ylim(35, NA)

(
  (p1 / p2) &
    scale_color_pomological() &
    theme_pomological_fancy(base_family = "Marck Script") &
    theme(legend.position = "none")
) +
  plot_annotation(subtitle = "Weakly informative priors cleared up the condition right away")
```

Figure 9.10
```{r}
post <- as_draws_df(b9.3)

# left
p1 <-
  post %>% 
  select(b_Intercept) %>% 
  
  ggplot(aes(x = b_Intercept)) +
  geom_density(trim = T) +
  geom_line(data = tibble(x = seq(from = -15, to = 15, length.out = 50)),
            aes(x = x, y = dnorm(x = x, mean = 0, sd = 10)),
            color = pomological_palette[5], linetype = 2) +
  xlab(expression(alpha))

# right
p2 <-
  post %>% 
  select(sigma) %>% 
  
  ggplot(aes(x = sigma)) +
  geom_density(trim = T) +
  geom_line(data = tibble(x = seq(from = 0, to = 10, length.out = 50)),
            aes(x = x, y = dexp(x = x, rate = 1)),
            color = pomological_palette[9], linetype = 2) +
  labs(x = expression(sigma),
       y = NULL) +
  coord_cartesian(xlim = c(0, 10),
                  ylim = c(0, .7))

# combine
(
  (p1 + p2) &
    theme_pomological_fancy(base_family = "Marck Script")
) + plot_annotation(subtitle = "Prior (dashed) and posterior (solid) distributions for the\nmodel with weakly-informative priors, b9.3")
```

### 9.5.4 Non-identifiable parameters
```{r}
set.seed(9)
y <- rnorm(100, mean = 0, sd = 1)
```

```{r}
b9.4 <-
  brm(data = list(y = y,
                  a1 = 1,
                  a2 = 1),
      family = gaussian,
      y ~ 0 + a1 + a2,
      prior = c(prior(normal(0, 1000), class = b),
                prior(exponential(1), class = sigma)),
      iter = 2000, warmup = 1000, chains = 3,
      seed = 9,
      file = "fits/b09.04")
```

```{r}
print(b9.4)
```

Try again
```{r}
b9.5 <-
  brm(data = list(y = y,
                  a1 = 1,
                  a2 = 2),
      family = gaussian,
      y ~ 0 + a1 + a2,
      prior = c(prior(normal(0, 10), class = b),
                prior(exponential(1), class = sigma)),
      iter = 2000, warmup = 1000, chains = 3,
      seed = 9,
      file = "fits/b09.05")
```

```{r}
print(b9.5)
```

```{r}
trace_rank <- function(data, var, subtitle = NULL, ymin = NA) {
  
  p1 <-
    data %>% 
    mcmc_trace(pars = var,
               linewidth = 0.25,
               facet_args = list(ncol = 1)) +
    labs(subtitle = subtitle,
         y = NULL) +
    facet_wrap(~ parameter)
  
  p2 <-
    data %>%
    mcmc_rank_overlay(pars = var) +
    coord_cartesian(ylim = c(ymin, NA)) +
    xlab(NULL)
  
  tr <- p1 + p2
  
  tr
  
}
```

```{r}
# b9.4
post <- as_draws_df(b9.4)

p1 <- trace_rank(data = post, var = "b_a1", subtitle = "b9.4 (bad priors)")
p2 <- trace_rank(data = post, var = "b_a2")
p3 <- trace_rank(data = post, var = "sigma")

# b9.5
post <- as_draws_df(b9.5)

p4 <- trace_rank(data = post, var = "b_a1", subtitle = "b9.5 (good priors)", ymin = 30)
p5 <- trace_rank(data = post, var = "b_a2", ymin = 30)
p6 <- trace_rank(data = post, var = "sigma", ymin = 30)

# combine!
(p1 / p2 / p3 / p4 / p5 / p6) &
  theme_pomological_fancy(base_family = "Marck Script") &
  theme(legend.position = "none")
```

